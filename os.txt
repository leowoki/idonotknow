1.。。。
windows:基于MS-DOS

linux/unix；。。。。。

mac:基于UNIX内核的图形化操作系统

操作系统与普通软件：
    无操作系统，计算机能运行程序，如BIOS
    无操作系统，普通用户不能使用

基本功能：
    提供操作界面
    控制程序运行
    管理系统资源
    配置系统参数
    监控系统状态
    工具软件集合

操作系统的功能一：进程管理（CPU管理）
	进程控制：创建。暂停，唤醒，撤销
	进程调度：调度策略。优先级
	进程通信：进程间通信
操作系统的功能二：内存管理
	内存分配
	内存共享
	内存保护
	虚拟内存
操作系统的功能三：设备管理功能
	设备的分配和调度
	设备无关性作
	设备传输控制
	设备驱动
操作系统的功能四：文件管理
	存储空间管理
	文件的操作
	目录的操作
	文件和目录的存取权限管理 


操作系统定义
操作系统是一个大型系统程序
	提供用户接口，方便用户控制计算机
	负责为应用程序分配和调度软硬件资源，并控制与协调应用程序并发活动，帮助用户存取和保护信息


操作系统地位：

		各种各样应用程序                ---------应用程序
	调试程序	装入程序	编辑程序---------系统程序
	编译程序	汇编程序	装配程序
			操作系统
			机器语言         -----------------硬件部分
			微程序
			裸机

计算机硬件发展历史：用户需求提升和硬件技术进步
	电子管
	晶体管
	集成电路
	大规模集成电路

操作系统发展阶段：
	手工操作(无操作系统)
	单道批处理系统
	多道批处理系统
	分时系统



中断技术：
	CPU收到外部信号(中断信号)，停止当前工作，转去处理外部事件，处理完毕后回到原来中断处(断点)继续原来工作

通道技术：
	专门处理外设与内存之间的数据传输的处理机制

分时技术：
	主机以很短的“时间片”为单位，把CPU轮流分配给每个终端使用，直到全部作业被运行完
	等待周期=时间片*终端数量

分时系统特点：
	多路调制性：多用户联机使用一台计算机
	独占性：用户感觉独占计算机
	交互性：及时向应用户请求

分时操作系统衍化：
微机操作系统
	良好层次结构：BIOS把操作系统和硬件分隔
多处理机操作系统
网络操作系统
	普通操作系统+网络通信+网络服务
	功能：透明存取，存取控制
实时操作系统
	强调作业完成时限
嵌入式操作系统
	约等于实时系统操作
	软硬件可裁剪，软硬件一体化的系统


适合学习的小型开源操作系统：
	minix os: http://www.minix3.org/
	linux1.0



2.。。。
操作系统逻辑结构：
逻辑结构
	OS的设计和实现思路
逻辑结构种类
	整体式结构
		以模块为基本单位构建
		特点
			模块设计，编码，调试独立
			模块调用自由
			模块通信多以全局变量形式完成
		缺点
			信息传递随意，维护和更新困难
	层次式结构
		所有功能模块按照调用次序排成若干层，相邻层间只有单项依赖或单向调用
		分层原则
			硬件相关--最底层
			外部特性--最外层
			中间层--调用次序或消息传递顺序
			共性的服务--较低层
			活跃功能--较低层
		特点
			结构清晰，避免循环调用
			整体问题局部化，系统的正确性容易保证
			有利于操作系统维护，扩充，移植
	微内核结构(客户/服务器结构，Clinet/Server)
		操作系统=微内核+核外服务
		微内核
			足够小，提供OS最基本的核心功能和服务
				实现与硬件紧密相关的处理
				实现一些较基本的功能
				负责苦湖和服务器间的通信
		核外服务器
			完成OS绝大部分服务功能，等待应用程序提出请求
				由若干服务器或进程共同构成，EG：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式在用户态


支持操作系统的最基本硬件结构
	CPU
		CPU态(Mode)
			CPU的工作状态
			对资源和指令(特权指令)使用权限的描述
	
		态的分类
			核态(Kernel mode)
				能够访问所有资源和执行所有命令
				管理程序/OS内核
			用户态(User mode 目态)
				仅能访问部分资源，其他资源受限
				用户程序
			管态(Supervisor mode)
				介于核态和用户态之间
		
		用户态和核态之间的转换
			用户态向核态转换
				用户请求OS提供服务
				发生中断
				用户进程产生错误(内部中断)
				用户态企图执行特权指令
			核态向用户态转换情形
				一般是执行中断返回：IRET

		硬件和OS对CPU的观察
			硬件按“态”来区分CPU的状态
			OS按“进程”来区分CPU的状态

		Inter CPU的态
			Ring0~Ring3(Ring0最核心)
			程序段A访问程序段B时进行权限检查(态)
			程序段：请求特权级，RPL
				Requested Privilege Level
				RPL=0..3
			程序段：描述符特权级，DPL
				Descriptor Privilege Level
				DPL=0..3
		windows：Ring0和Ring3之间的通信
			DeviceIoControl(kernel32.dll)

	存储器
		存储程序和数据的部件
		
		分类
			按存储器(半导体存储器)读写方式
				RAM
				ROM
			按存储元的材料
				半导体存储器(常作主存)
				磁存储器(磁带，磁盘)
				光存储器(光盘)
			按与CPU的联系
				主存：直接和CPU交换信息
				辅存：不能直接和CPU交互信息

			理想存储体系：速度快，容量大，成本低
			实际存储体系：
				寄存器
				高速缓存(CACHE)
				主存
				辅存

			分级存储系统工作原理
				CPU读取指令或数据时的访问顺序
					访问缓存(命中，HIT)
					访问内存(没有命中，MISS)
					访问辅存(缺页，PAGE_FAULT)			
				
	中断
		指CPU对突发的外部事件的反应机制或过程
		CPU收到外部信号(中断信号)，停止当前工作，转去处理外部事件，处理完毕后回到原来中断处(断点)继续原来工作
		
		目的：实现并发活动
			  实现实时处理
			  故障自动处理

		中断源
			引起系统中断的事件
		中断类型
			强迫性中断和自愿中断：
				强迫性中断：程序没有预期，例：I/O，外部中断
				自愿中断：程序有预期，例：执行访管指令
			外中断(中断)和内中断(俘获)：
				外中断：由CPU外部事件引起，例：I/O，外部事件
				内中断：有CPU内部事件引起，例：访管中断，程序中断
			外中断：不可屏蔽中断和可屏蔽中断
				不可屏蔽中断：中断的原因很紧要，CPU必须响应
				可屏蔽中断：中断的原因不很紧要，CPU可以不响应
		
		断点
			程序中断的地方，将要执行的下一指令的地址
			CS:IP
		现场
			程序正确运行所依赖的信息集合
			相关寄存器
		现场的两个处理过程：
			现场的保护：进入中断服务程序之前，栈
			现场的恢复：退出中断服务程序之后，栈

		中断响应过程：
			识别中断源
			保护断点和现场
			装入中断服务程序的入口地址(CS:IP)
			进入中断服务程序
			恢复现场和断点
			中断返回：IRET

		响应实质：
			交换指令执行地址
			交换CPU的态
			工作：现场的保护和恢复，参数传递(通信)

	时钟
		........


3.。。。

操作系统启动过程
BIOS和主引导记录MBR
	计算机工作模式：实模式和保护模式
		实模式(实地址模式，REAL MODE)
			程序按照8086寻址方法访问0h--FFFFFh(1M)空间
			寻址方式：物理地址(20位)=段地址(16位)：偏移地址(16位)
			CPU单任务运行

			前640K[00000--9FFFF]：基本内存
			中128K[A0000--BFFFF]：显卡显存
			后256K[C0000--FFFFF]：BIOS

			C0000--C7FFF：显卡BIOS
			C8000--CBFFF：IDE控制器BIOS
			F0000--FFFFF：最后64KB，系统BIOS

		保护模式(内存保护模式，PROTECT MODE)
			寻址方式：段(32位)和偏移量(32位)，寻址4GB空间
				段属性：起始地址，存取属性，权限级别。。
			段页式寻址机制(段，页)
			虚拟地址，进程，封闭空间
			应用程序和操作系统的运行环境被保护
			CPU支持多任务

		系统BIOS
			Basic I/O System(Firmware,固件：以硬件方式存在的软件或软件)
			基本输入/输出系统
			位置：F0000--FFFFF
			功能：
				系统启动配置
					CMOS设置
				基本的设备I/O服务
					BIOS使用的中断类型号为10H~1FH
				系统的加电自检和启动
					加电自检POST：
						Power On Slef-Test
						初始化基本硬件
							CPU，内存，显卡。。。
						自检正常不提示，错误则通过喇叭提示
					按下PowerOn或者Reset键执行第一条指令
						执行FFFF0处指令：JUMP POST ;POST位于系统BOIS内部

		POST之后
			查找显卡BIOS，调用显卡BIOS
			依次查找其他设备执行相应设备的BIOS
			显示启动画面
			从硬盘/软盘/光驱/U盘读入OS
				MBR
					存放在硬盘/软盘的首扇区
					存放和OS启动相关信息(Main Boot Record)
					512BYTES
					结束：0xAA55h

					分区启动扇区：BootLoader，PBR
					主启动扇区：完成OS加载或启动管理功能。
						提供菜单：让用户选择不同启动项，实现多重启动
						加载核心文件：直接指向可启动区加载操作系统
						跳转：将启动管理功能转交给其他loder
			OS启动后，由OS接管计算机
操作系统启动过程
	从加电到用户工作环境准备好的过程
		初始引导
			把OS核心装入内存并使之开始工作接管计算机系统
		核心初始化
			OS内核初始化系统的核心数据
		系统初始化
			为用户使用系统作准备，使系统处于待命状态
	
操作系统生成
	满足特定硬件环境和用户需求，组装和构建操作系统过程

	主要步骤：
		根据硬件环境/用户要求配置功能模块和构造参数
		构建OS镜像
	前提：
		操作系统由可拆装模块构成
		有交互式配置工具
		有映像构建工具
	
	linux操作系统生成：
		获取LINUX内核源代码
			http://www.kernel.org/
			cd /usr/src
			tar zxvf linux-2.6.38-12.tar.gz
		选择和启动内核配置程序
			cd /usr/src/linux-2.6
			//make config(文本界面)
			//make xconfig(图形窗口模式，xWindows使用)
			make menuconfig(文本选择界面，字符终端)
		根据需求配置内核模式和参数
			。。。。。
		重新编译新内核
			make dep 生成依赖dependency信息
			make clean 清除旧的编译结果
			make bzImage ./arch/i386/boot/bzImage
		编译和安装模块
			make modules
			make modules install 模块被编译且安装到/usr/lib<内核版本号>目录下
		启动新内核(具体过程与版本有关)
			cp bzImage /boot/bzImage
			配置/boot/grub/grub.conf

用户界面
	定义：OS提供给用户控制计算机的机制，又称用户接口
	分类：
		操作界面：
			图形用户接口：窗口，图标，菜单，按钮，鼠标(消息，事件)
			键盘命令(cammand)：在控制台环境下接受键盘输入的命令
							   类型：普通命令，批处理命令，shell
							   批处理：
									普通命令的集合，批执行，由command解释执行
									支持变量替换，条件，转移，循环，注释等简单语法
									*.BAT
								shell：
									操作系统与用户交互的界面
									表现为通过控制台执行用户命令三方式
									本身不执行，仅仅组织和管理命令

									脚本编成：通过类似程序的方式执行具有一定逻辑顺序的命令序列完成较复杂的功能和人机交互
									脚本程序保存在文本文件中
									脚本程序是shell命令语句的集合
									shell脚本程序由shell环境解释执行
									执行shell脚本文件需要具有可执行属性(x)
										chmod +x myscript.sh
									运行脚本方法：
										直接运行(用缺省版本的shell运行脚本程序)
										使用特定版本的shell执行脚本
										在脚本文件首行指定shell
		系统调用：操作系统内核为应用程序提供的服务/函数
			特点：
				一般涉及核心资源或硬件的操作
				运行与核态(内核空间)
				每个系统调用具有唯一编号：ID
				调用过程会产生中断，自愿中断
			隐式系统调用：
				类似API函数
				在高级语言中使用
				包含“INT 80h”中断指令，执行相应的系统调用


进程：
	并发环境中问题：
		运行过程不确定
		结果不可再现(程序运行被干扰)
		解决方案：对程序运行加相互制约
	
	进程定义：
		描述和管理程序的”运行过程”
		进程是程序在某个数据集合上一次运行活动
		数据集合：软/硬件环境，多个进程共享/共存的环境
	
	进程特征：
		动态性：进程是程序一次执行过程，动态产生/消亡
		并发性：进程同其他进程一起向前推进
		异步性：进程按各自速度向前推进
		独立性：进程是系统分配资源和调度CPU的单位
	
	进程/程序区别：
		动态与静态：进程是动态的，是程序的一次执行过程;程序是静态的，是一组指令的有序集合
		暂存与长存：进程是暂存的，在内存中驻留；程序是长存的，在介质上长期保存
		程序和进程对应：一个程序可以有多个进程
	
	进程类型：
		按使用资源权限：
			系统进程：指系统内核相关进程
			用户进程：运行于用户态的进程
		按对CPU依赖性：
			偏CPU进程：计算型进程
			偏I/O进程：侧重于I/O的进程

	进程状态：
		运行状态(running)：进程已经占有CPU，在CPU上运行
		就绪状态(ready)：具备运行条件但由于无CPU，暂时不能运行
		阻塞状态(block)(等待(wait)状态)：因等待某项服务完成或信号不能运行状态，如等待：系统调用，I/O操作，合作进程信号。。。
	
	状态变迁：进程状态可依据一定条件相互转换
		就绪->运行：进程调度
		运行->就绪：时间片到；被抢占
		运行->阻塞：请求服务；等待信号
		阻塞->就绪：服务完成；信号来到

	LINUX进程状态：
		可运行态：TASK_RUNNING
			就绪：在就绪队列中等待调度
			运行：正在运行
		阻塞态：
			浅度阻塞：TASK_INTERRUPTIBLE可中断，能被其他进程的信号或时钟唤醒
			深度阻塞：TASK_UNINTERRUPTIBLE不可中断，不能被其他进程的信号或时钟唤醒
		僵死态：TASK_ZOMBIE
			进程终止执行，释放大部分资源
		挂起态：TASK_STOPPED
			进程被挂起

	LINUX进程状态变迁：
													fork()
													 |
													 |
	    --收到信号-->							TASK_RUNNING   <--资源到位或收到信号
		|		-->								就绪                    |
		|	    |资源到位							||时间片耗尽    TASK_INTERRUPTIBLE
		|       |								    ||                  |
		|	TASK_UNINTERRUPTIBLE <--等待资源--  占有CPU资源 -->等待资源到位
		|	深度阻塞							    ||
		|											||		
		|											||
		|--TASK_STOPPED<--ptrace()---				||---do_exit()-->TASK_ZOMBIE僵死

	进程控制块(PCB)
		描述进程状态，资源和与相关进程关系的数据结构
		PCB是进程的标志
		创建进程时创建PCB；进程撤销后PCB同时消失
	进程=程序+PCB
	
	PCB中基本成员。。。。。。	

	LINUX进程标识：
		PID
		PPID：父进程ID
		PGID：进程组ID
	LINUX进程用户标识：
		UID：用户ID
		GID：用户组ID

	进程切换：
		进程上下文：
			context，进程运行环境，CPU环境
		进程切换过程：
			换入进程的上下文进入CPU(从栈上来)
			换出进程的上下文离开CPU(从栈上去)

	进程控制：在进程生存全期间，对其全部行为的控制
		创建进程
			功能：创建一个具有指定标识(ID)的进程
			参数：进程标识，优先级，进程起始地址，CPU初始状态，资源清单...
			过程：
				创建空白PCB
				获得并赋予进程标识符ID
				为进程分配空间
				初始化PCB：默认值
				插入相应的进程队列：新进程插入就绪队列
	
		阻塞进程
			功能：停止进程执行，变为阻塞
			阻塞的时机/事件：
				请求系统服务
					由于某种原因，OS不能立即满足进程的要求
				启动某种操作
					进程启动某操作，阻塞等待该操作完成
				新数据尚未到达
					A进程要获得B进程的中间结果，A进程等待
				无新工作可作
					进程完成任务后，自我阻塞，等待新任务到达
			参数：阻塞原因，不同原因构建不同阻塞队列
			过程：
				停止运行
				将PCB"运行态"改"阻塞态"
				插入相应原因的阻塞队列
				转调度程序

		撤销进程
			功能：撤销一个指定进程，收回进程所占有资源，撤销该进程的PCB
			进程撤销的时机/事件：
				正常结束
				异常结束
				外界干预
			参数：被撤销进程名(ID)
			过程：	
				在PCB队列中检索出该PCB
				获取该进程的状态
				若该进程处在运行态，立即终止该进程
					递归检查是否有子进程，先撤销子进程
				释放进程占有资源
				将进程从PCB队列中移除

		唤醒进程
			功能：唤醒处于阻塞队列当中的某个进程
			引起唤醒的时机/事件：
				系统服务由不满足到满足
				I/O完成
				新数据到达
				进程提出新请求(服务)
			参数：被唤醒进程的标识

	进程控制原语：
		由若干指令构成的具有特定功能的函数
		具有原子性，其操作不可分割

		进程控制原语：
			创建原语
			撤销原语
			阻塞原语
			唤醒原语

	windows进程控制：
		system()
		WinExec()
		ShellExecute()
		CreateProcess()：最基本
	CreateProcess()创建进程：
		创建进程内核对象，创建虚拟地址空间
		装载EXE/DLL的代码和数据到地址空间中
		创建主线程和线程内核对象
		启动主线程，进入主函数(main)	
	结束进程：
		ExitPricess
			VOID ExitPricess(UINT uExitCode)
		TerminateProcess(任务管理器强制结束任务)
			TerminateProcess(
			HANDLE hProcess,
			UINT uExitCode)
	
	linux进程控制：
		fork()创建进程：pid_t fork(void)
			新进程是当前进程的子进程
			父进程和子进程：
				父进程：fork()的调用者
				子进程：新建的进程
			子进程是父进程的复制
			父进程和子进程并发运行

		fork()返回值
			在子进程中，pid=0
			在父进程中，pid>0(子进程ID)
			出错：pid=-1

		fork函数实现：在文件/kernel/fork.c中do_fork函数

		exec函数簇(包含若干函数)
			功能：装入一个指定的可执行程序运行
			      使子进程具有和父进程完全不同的新功能
			步骤：
				  根据文件名找到相应的可执行程序
				  将可执行程序填入子进程的地址空间
				  进入新进程执行且不再返回

线程：
	线程是可由CPU直接运行的实体
	一个进程可以创建多个线程
	多个线程共享CPU可以实现并发运行

	windows创建线程：
		CreateThread()
			功能：把一个函数创建为一个线程
			原型：DWORD ThreadFunction(
			LPVOID IpParameter )
		单线程程序：
			整个进程只有一个线程，windows程序缺省只有一个线程(主线程，main线程)
		多线程程序：
			整个进程至少有两个线程，主线程和至少一个用户线程

	线程应用场景
		多个功能需要并发的地方
		需要改善窗口交互性的地方
		需要改善程序结构的地方
		多核CPU上的应用，充分发挥多核性能

	使用线程的麻烦：
		程序难以调试
		线程安全问题
		并发过程难以控制

	临界资源
		一次只允许一个进程独占访问(使用)的资源
	临界区
		进程中访问临界资源的程序段
	访问特点：
		具有排他性
		并发进程不能同时进入临界区
	设计临界区访问机制：
		忙则等待：当临界区忙时，其他进程必须在临界区外等待
		空闲让近：当无进程处于临界区时，任何有权进程可进入临界区
		有限等待：进程进入临界区的请求应在有限时间内得到满足
		让权等待：等待进程放弃CPU(让其他进程有机会得到CPU)

	锁机制
		基本原理
			设置一个"标志"S；表明临界资源"可用"还是"不可用"
			上锁操作：进入临界区之前检查标志是否可用？
				可用：访问临界资源，且将标志修改为不可用
				不可用：进程在临界区之外等待
			开锁操作：退出临界区时将标志修改为可用

		上锁操作：上锁原语实现
			检查S锁状态
			若S=0，则返回第一步
			若S=1，则置其为0
		开锁操作：开锁原语
			把锁S状态置1

		步骤：
			初始化锁的状态S=1(可用)
			进入临界区之前执行上锁Lock(s)操作
			离开临界区之后执行开锁UnLock(s)操作

	互斥：
		多个进程由于共享独占性资源，必须协调各进程对资源的存取顺序，确保没有任何两个或以上进程同时进行存取操作
		互斥和资源共享相关
		资源：临界资源
		存取操作区域：临界区
	同步：
		若干合作进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要另一个进程已经完成某个操作，否则前面的进程只能等待
		合作进程中某些操作之间需要满足某种先后关系或某个操作能否进行需要满足某个前提条件，否则只能等待

	互斥关系属于特殊的同步关系

	P-V操作：
		信号灯是一种卓有成效的进程同步机制
		进程在运行过程首信号灯状态控制，并能改变信号灯状态
			进程受控制：信号灯的状态可以阻塞或唤醒进程
			改变信号灯：信号灯的状态可以被进程改变

		信号灯数据结构：
			信号灯变量定义为一个二元矢量(S,q)
			S：整数，初值非负，(S又称信号量)
			q：PCB队列，初值为空集

	P操作(函数或过程，P(S,q)),Passeren 通过
	V操作(函数或过程，V(S,q)),Vrijgeven释放

	P操作原理：(P(S,q),P(S))
		S值-1；
		若差大于或等于0，该进程继续
		若差小于0，则该进程阻塞并加入队列q中并转调度函数
		注：P操作可能使进程在调用处阻塞，S初值很重要

	V操作原理：(V(S,q),V(S))
		S值+1；
		若和大于0，该进程继续
		若和小于或等于0，则该进程继续同时从q中唤醒一个进程
		注：V操作可能会唤醒阻塞的进程

	P-V操作解决互斥问题：
		实质是实现对临界区的互斥访问，允许最多一个进程处于临界区
		应用过程：S初值设置合理
			进入临界区之前执行P操作(可能阻塞当前进程)
			离开临界区之后执行V操作(可能唤醒某个进程)
	P-V操作解决同步问题：
		同步实质：
			运行条件不能满足时，能让进程暂停
			运行条件满足时，能让进程立即继续
		基本思路：
			暂停当前进程：在关键操作之前执行P操作
				必要时可暂停
			继续进程：在关进操作之后执行V操作
				必要时唤醒合作进程
			定义有意义的信号量S，并设置合适的初值
				信号量S能明确表示"运行条件"

	windows同步机制：
		临界区(锁)
			在进程内使用，保证仅一个线程可以申请到该对象
			临界区内是临界资源的访问
			相关API函数。。。。
		互斥量(锁)
			保证只有一个线程或进程可以申请到该对象
			可以跨进程使用
			可以有名称
			互斥量比临界区耗费更多资源，速度慢

		信号量
			允许指定数目的多个进程/线程访问临界区
			一种资源计数器，用于限制并发线程的数量
			初始值可设为N，则表示允许N个进程/线程并发访问资源
		
			信号量的值可以通过相应函数增或减
			信号状态：值大于0时，有信号状态
					  值小与等与0时，无信号状态
		
		事件
			。。。
		等待操作
			。。。

	linux父子进程同步
		进程阻塞wait()
		进程终结exit()
		进程休眠sleep()
	父子进程共享普通变量：对于普通变量，父子进程各自操作变量副本，互不影响
	父子进程共享文件资源：对于文件，父子进程共享同一文件和读写指针

	
	进程间通信
		widows匿名管道通信
			管道定义(pipe)：管道是进程间的一种通信机制，A进程可以通过管道把数据传输给B进程，A向管道输入数据，B从管道读取数据
			工作原理：
				管道像文件一样可读可写，有读/写2个权柄CreatePipe(Handle W,Handle R)
				通过写写句柄(W)向管道写入数据：WriteFile(W,Buffer)或通过输出重定向向写句柄(W)写入
				通过读读句柄(R)向管道读取数据：ReadFile (R,Buffer)或通过输入重定向向读句柄(R)读出
			注意事项：仅能用于父子或兄弟进程间通信
				由父进程创建管道CreatePipe(W,R)
				由父进程创建子进程CreateProcess()
				父进程写或读管道，子进程输入和输出重定向管道
			双向通信：必须建立在2个管道
				要支持程序间双向通信，父进程必须建立创建2个管道

		linux信号通信
			信号概念：(signal)
				信号是linux进程间一种重要通信机制
				信号是向进程发送的一个通知，通知某个事件发生
				收到信号的进程可以立即执行指定的操作
				信号的发出可以是进程，也可以是系统(硬件)
			信号产生：
				键盘输入特殊组合键产生信号
				执行终端命令产生信号
				程序中调用函数产生信号
				硬件异常或内核产生相应信号
			singal()注册信号处理函数的函数
				原型：
					void signal(
					int SigNo		   //信号编号
					void (*Handle)int  //自定义信号处理函数)
				功能：
					为指定信号注册信号处理函数，当进程收到SigNo信号时，立即自动调用Handle函数执行
					一般在进程初始化时使用该函数注册信号处理函数			

			kill()发送信号的函数
				原型：
					void kill(
					int PID     //接受信号的目标进程ID
					jint SigNo  //待发送的信号)
				功能：向目标进程PID发送SigNo信号
					

5.。。。。
死锁：
	定义：两个或多个进程无限期等待永远不会发生的条件的一种状态/在两个或多个进程中，每个进程都持有某种资源，但又继续申请其他进程以持有的某种资源，此时每个进程都拥有其运行所需的一部分资源，但又不够，从而每个进程都不能向前推进，陷于阻塞状态
	结果：每个进程都永远阻塞

	起因：
		系统资源有限：资源数目不足，进程对资源的竞争而产生死锁
		并发进程的推进顺序不当：进程请求资源和释放资源的顺序不当，导致死锁

	结论：
		参与死锁的进程至少是2个
			2个或以上进程才会出现死锁
		参与死锁的进程至少有2个以占有资源
		参与死锁的所有进程都在等待资源
		参与死锁的进程是当前系统中所有进程的子集
			死锁会浪费大量系统资源，甚至导致系统崩溃


	必要条件：
		互斥条件：进程互斥使用资源，资源具有独占性
		不剥夺条件：进程在访问完资源前不能被其他进程强行剥夺
		部分分配条件：进程边运行边申请资源，临时需要临时分配(区别于：全部分配)
		环路条件：多个进程构成环路，环中每个进程已占用的资源被前一进程申请，而自己所申请资源又被环中后一进程占用着

	解决死锁策略：
		预防死锁：通过设置某些限制条件，破坏死锁4个必要条件中的一个或多个来防止死锁
			互斥条件...............难
			不剥夺条件.............代价大
			部分分配条件...........预先静态分配
			环路条件...............有序资源分配

			较易实现，早期广泛使用，缺点：由于限制太严格，导致资源利用率和吞吐量降低

		避免死锁：不事先采取限制去破坏产生死锁的条件，而是在资源分配过程中，用某种方法去评估若分配资源是否会让系统进入死锁状态，若是，则拒绝此次分配资源，从而避免死锁的发生
			银行家算法
			只需要较弱的限制条件，可获得较高的资源利用率和系统吞吐量，缺点：实现较难
		
		检测和恢复死锁：允许死锁发生，但可通过检测机制即使检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中以发生的死锁清除，将进程从死锁状态解脱出来
			缺点1：检测方法复杂，实现难度大
			缺点2：恢复方法靠人工，撤销一些进程，回收资源再分配

			预先静态分配法。。。。
			有限资源分配法。。。。


6.。。。。
进程调度
	定义：在合适的时候以一定策略选择一个就绪进程运行
	目标：下述部分原则存在相互矛盾
		响应速度尽可能快			
		进程处理的时间尽可能短
		系统吞吐量尽可能大
		资源利用率尽可能高
		对所有进程要公平
		避免饥饿
		避免死锁
	两个量化目标：
		周转时间/平均周转时间
			进程提交给计算机到最终完成所花费的时间(t)
			t=tc-ts
			ts：进程的提交时间(start)
			tc：进程的完成时间(complete)
			意义：说明进程在系统中停留时间长短
			t=(t1+t2+t3...+tn)/n
			意义：平均周转时间越短，意味着这些进程在系统内停留的时间越短，因而系统吞吐量也就越大，资源利用率也就越高

		带权周转时间/平均带权周转时间
			w=t/tr
			t：进程的周转时间
			tr：进程的运行时间(run)
			w=(w1+w2+....+wn)/n

	典型的调度算法：
		先来先服务调度(first come first serve)
			算法：按照作业进入系统的时间先后来挑选作业，先进入系统的作业优先被运行
			特点：容易实现，效率不高，
				  只考虑作业的等候时间，而没有考虑运行时间的长短，因此一个晚来但是很短的作业可能因为需要等待很长时间才能运行，因而本算法不利于短作业

		短作业优先调度(short job first)
			算法：参考运行时间，选取运行时间最短的作业投入运行
			特点：易于实现，效率不高，
				  忽视了作业等待时间，一个早来但是很长的作业将会在很长时间得不到调度，易出现资源"饥饿"的现象

		响应比高者优先调度
			响应比定义：作业的响应时间和运行时间的比值
			响应比=响应时间/运行时间=(等待时间+运行时间)/运行时间=1+等待时间/运行时间
			算法：计算每个作业的响应比，选择响应比最高的作业优先投入运行
			特点：响应比=1+等待时间/运行时间，
				  若作业等待时间相同，则运行时间越短的作业，其响应比越高，因此越容易被调度，因而有利于短作业
				  若作业运行时间相同，则等待时间越长的作业，其响应比越高，因此越容易被调度，因而有利于等候长的作业
				  对于运行时间长的作业，其优先级可以随等待时间的增加而提高，当其等待足够久的时候，也有可能获得CPU
		优先数调度
			算法：根据进程优先数，把CPU分配给最高的进程
				  进程优先数=静态优先数+动态优先数
			静态优先数：进程创建时间时确定，在整个进程运行期间不再改变
				确定：基于进程所需的资源多少
					  基于程序运行时间的长短
					  基于进程的类型[IO/CPU，前台/后台，核心/用户]
			动态优先数：动态优先数在进程运行期间可以改变
				确定：当时用CPU超过一定时长时
					  当进行I/O操作后
					  当进程等待超过一定时长时

		循环轮转调度(round-robin)
			概念：把所有就绪进程按先进先出的原则排成队列，新进来进程加到队列末尾
				  进程以时间片q为单位轮流使用CPU，刚刚运行一个时间片的进程排到末尾，等候下一轮运行
				  队列逻辑上是环形的
			优点：
				  公平性：每个就绪进程有平等机会获得CPU
				  交互性：每个进程等待(N-1)*q的时间就可以获得CPU
			时间片q的大小：
				  若q太大：交互性差，甚至退化为fcfs调度算法
				  若q太小：进程切换频繁，系统开销增加
			改进： 
				  时间片大小可改变
				  组织多个就绪队列
	
	linux进程类型
		普通进程：采用动态优先级来调度
				  调度程序周期性地修改优先级(避免饥饿)
	
		实时进程：
				  采用静态优先级来调度
				  由用户预先指定，以后不会改变
	
		静态优先级：进程创建时指定或由用户修改
	
		动态优先级：在进程运行期间可以按调度策略改变
					非实时进程采用动态优先级，由调度程序计算
					只要进程占用CPU，优先级就随时间流失而不断减少
					task_struct的counter表示动态优先级
	
		调度策略(结合task_struct结构)
			SCHED_OTHER   0  普通的分时进程
			SCHED_FIFO    1  实时进程
			SCHED_RR      2  实时进程
	
		实时进程：
			SCHED_FIFO(先进先出)
				当前实时进程一直占用CPU直至退出或阻塞或被抢占
				阻塞后再就绪被添加到同优先级队列末尾
			SCHED_RR(时间片轮转)
				与其他实时进程以Round-Robin方式共同使用CPU
				确保同优先级的多个进程能共享CPU
	
		非实时进程：
			SCHED_OTHER(动态优先级)
			counter成员表示动态优先级
	
		调度策略的改变：
			系统调用schde_setscheduler()改变调度策略
			实时进程的子孙进程也是实时进程
	
		进程调度依据：
			task_struct:policy
						priority
						rt_priority
						counter
	
		动态优先级与counter：
			counter值的含义
				进程能连续运行的时间，单位是时钟滴答tick
					时钟中断周期tick为10ms，若counter=60，则连续运行600ms
				较高优先级的进程一般counter较大
				一般把counter看作动态优先级
			counter的初值与priority有关
				普通进程创建时counter的初值为priority的值
			counter的改变
				时钟中断tick时，当前进程的counter减1，直到为0被阻塞
	
		子进程新建时的counter
			新建子进程counter从父进程时间片conter中继承一半
			防止用户无限制的创建后代进程而长期占有CPU资源
	调度时机
		中断处理过程中直接使用调用schedule()
			时钟中断，I/O中断，系统调用和异常
			内核被动调度的情形			
		中断处理过程返回用户态时直接调用schedule()
			必须根据need_resched标记
		内核线程可直接调用schedule()进程切换
			内核主动调度的情形
		用户态进程只能通过陷入内核后在中断处理过程中被动调度
			必须根据need_resched标记

	进程切换
		概念：
			内核挂起当前CPU上的进程并恢复之前挂起的某个进程
			任务切换，上下文切换
		与中断上下文的切换有差别：
			中断前后在同一进程上下文中，只是用户态转向内核态执行
		进程上下文包含进程执行需要的所有信息：
			用户地址空间：包括程序代码，数据，用户堆栈。。。
			控制信息：进程描述符，内核堆栈。。。
			硬件上下文：注意中断也要保存硬件上下文只是保存的方法不同
	
	进程调度和切换流程：
		schedule()函数
	
	基本进程：
		正在运行用户态进程A
		发生中断(譬如时钟中断)
			保存current当前进程的cs:eip/esp/eflags到内核堆栈
			从内核堆栈装入ISR中断服务例程的cs:sip和ss:esp
		SAVE_ALL
		中断处理过程中或中断返回前调用schedule()
			其中的switch_to做了进程上下文切换
		运行用户态进程B
		RESTORE_ALL
		iret继续运行用户态进程B








































































	



